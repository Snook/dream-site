How to add csrf and double submission protection to a form

Please use the CForm class to implement all critical forms.

1) When creating the CForm object pass a unique string id. The protection is specific to the form and
	 page loads and therefore the system can handle multiple windows or tabs within the same browser.

	 	$Form = new CForm('customer_account_submit');

2) Be sure that the template file that contains the form tag echos the CForm hidden variables

	<?php if (isset($this->form_account[hidden_html])) echo $this->form_account['hidden_html'];?>

3) Where the submission is handled in the page logic add a check for token validation

		if ($_POST and isset($_POST['submit_account']))
		{
			if (!$Form->validate_CSRF_token())
			{
				$is_CSRF_valid = false;
			}
		}

4) Where the CForm is created but only if the form is NOT being submitted add the CForm method that injects the token:

			$Form->setCSRFToken();

	This might best be in an else clause where we check for form submission:

		if ($_POST and isset($_POST['submit_account']))
		{
			....
		}
		else
		{
			$Form->setCSRFToken();
		}


5) Handle a token validation failure. This can happen for the following reasons:

	a) The token as expired. The lifetime is currently set to 1 hour.
	b) The token is missing or invalid. Perhaps because a hacker has constructed a page to fraudulently submit a form.
		On our site this is more difficult because they also need the session id but they may be able to fool a logged in
		users to click a fraudulent link.
	c) A Double submission. The first submission will delete the key so the second submission should fail.
	d) The page was somehow loaded without the key (bug). Be sure all page loads inject the token.

	My current strategy if this occurs is skip the form submission handling code and then reload the page with an error message.


How to add Get Post Cleaning (GPC) to a form post:

There are actually 3 different approaches possible at the PHP level. It's harmless to combine approaches.

1)	Use the class.inputFilter_clean class.
2)  Utilize the static CGPC::do_clean function - individually for all Post variables
	Note: The variables are copied into the CGPC arrays after authentication but before the page logic is executed.
	By default the POST and GET arrays are left alone.  You may cause the POST and GET variables to be deleted by
	 setting the $this->use_GPC variable to true in a constructor.

	public function __construct()
	{
		$this->use_GPC = true;
	}

3)  Add the GPC to CForm elements as follows:

		// Email
		$Form->AddElement(array(CForm::type=> CForm::Text,
				CForm::name => "primary_email",
				CForm::placeholder => "*Email",
				CForm::dd_required => true,
				CForm::required_msg => "Please enter your email address.",
				CForm::tooltip => true,
				CForm::email => true,
				CForm::maxlength => 60,
				CForm::gpc_type => TYPE_STR,
				CForm::css_class => "medium"));


	 When AddElement is called it calls __CheckPost. This is a private function that checks for the post variable
	 and sets CForm's value array if it exists (if a default value exists this is used if no post variaible exists).
	  After AddElement the current value of the input can be retrieved using $Form->value('name');

	  if the gpc_type is provided = _CheckPost will clean it.




 mysql_real_escape_string



